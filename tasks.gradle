import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse

final String TRUE = 'true'
final String SH = 'sh'
final String DASH_C = '-c'
final String COPILOT = 'copilot'
final String MODULES_PROJECT = "modules"
final String COPILOT_MODULE = "com.etendoerp.copilot"
final String ARG_PROPERTY = "arg"
final String COPILOT_PORT_PROPERTY = "COPILOT_PORT"
final String OPENAI_API_KEY_PROPERTY = "OPENAI_API_KEY"
final String COPILOT_DOCKER_REPO = "etendo_copilot_core"
final String TOOLS_CONFIG_FILE = "tools_config.json"
final String COPILOT_IMAGE_TAG = 'COPILOT_IMAGE_TAG'
final String COPILOT_PULL_IMAGE = 'COPILOT_PULL_IMAGE'
final String COPILOT_DOCKER_CONTAINER_NAME = 'COPILOT_DOCKER_CONTAINER_NAME'
final String DEPENDENCIES_TOOLS_FILENAME = 'DEPENDENCIES_TOOLS_FILENAME'
final String BASE_MODULE_DIR = "modules"

final String EQUAL = '='

def jarsDir = new File(projectDir, "build${File.separator}etendo${File.separator}modules")
def sourceDir = new File(projectDir, "modules")

ext.sharedPrompt = ""
ext.errorMsg = null

private Iterable<File> processPropertiesFiles(File dir) {
    fileTree(dir: dir).matching {
        include '**/gradle.properties'
    }.each { file ->
        Properties properties = new Properties()
        file.withInputStream { stream ->
            properties.load(stream)
        }
        properties.each { key, value ->
            if (key.toString().startsWith('copilot.')) {
                tasks.create(name: key, group: 'copilot') {
                    finalizedBy 'copilot.do'
                    doLast {
                        sharedPrompt = value
                        for (def i = 0; i < 10; i++) {
                            String arg = "arg";
                            if (i > 0) {
                                arg = 'arg' + i
                            }
                            if (sharedPrompt.contains(arg)) {
                                if (!project.hasProperty(arg)) {
                                    errorMsg = "🤖 Please provide the parameter: " + arg + " (Ex. -P" + arg + "=value)"
                                    sharedPrompt = null
                                    return
                                }
                                sharedPrompt = value.replace('{' + arg + '}', project.findProperty(arg))
                            }
                        }
                    }
                }
            }
        }
    }
}

private String getToolsDependenciesFileName(Project project) {
    String toolsDependenciesFile = 'tools_deps.toml'
    try {
        Properties properties = envFile().properties
        String toolsDependenciesFileProp = properties.getOrDefault(DEPENDENCIES_TOOLS_FILENAME, toolsDependenciesFile).toString()
        String result = toolsDependenciesFileProp.isEmpty() ? toolsDependenciesFile : toolsDependenciesFileProp
        project.logger.info("Loaded TOOLS_DEPENDENCIES_FILE: ${result}")
    } catch (Exception e) {
        project.logger.info("Loaded TOOLS_DEPENDENCIES_FILE using default value: ${toolsDependenciesFile}")
        return toolsDependenciesFile
    }
}

processPropertiesFiles(jarsDir)
processPropertiesFiles(sourceDir)

task 'copilot.do' {
    doLast {
        def reader = new BufferedReader(new InputStreamReader(System.in))
        def yellowText = "\u001B[33;1m"
        def greenText = "\u001B[32;1m"
        def blueText = "\u001B[34;1m"
        def redText = "\u001B[31;1m"
        def resetText = "\u001B[0m"

        def etendoHost = project.findProperty('host')
        def username = project.findProperty('username')
        def password = project.findProperty('password')
        def app_id = project.findProperty("app_id")
        def role = project.findProperty("role")
        String question = project.findProperty("question")
        if (project.hasProperty("single")) {
            project.logger.lifecycle("${yellowText}🤖 Single mode enabled. Only one question will be asked.${resetText}")
        }

        if (username == null || username == "") {
            project.logger.lifecycle("${blueText}👮 Please provide the username:${resetText}")
            username = reader.readLine()?.trim()
        }
        if (password == null || password == "") {
            project.logger.lifecycle("${blueText}👮 Please provide the password:${resetText}")
            password = reader.readLine()?.trim()
            exec {
                commandLine 'clear'
            }
        }
        if (!etendoHost) {
            project.logger.lifecycle("${redText}🤖 Host not provided, using default (http://localhost:8080/etendo).${resetText}")
            etendoHost = "http://localhost:8080/etendo"
        }
        if (app_id == null || app_id == "") {
            project.logger.lifecycle("${redText}🤖 Please provide the parameter: app_id (Ex. -Papp_id=\'A1B2C3D4E5F6G7H8\').${resetText}")
            return
        }

        String login = JsonOutput.toJson([
                "username": username,
                "password": password
        ] + (role != null && !role.isEmpty() ? ["role": role] : [:]))

        String loginURL = "${etendoHost}/sws/login"

        HttpClient hClient = HttpClient.newHttpClient()
        HttpRequest hRequest = HttpRequest.newBuilder()
                .uri(URI.create(loginURL))
                .header("Content-Type", "application/json")
                .method("POST", HttpRequest.BodyPublishers.ofString(login))
                .build()

        HttpResponse<String> hResponse = hClient.send(hRequest, HttpResponse.BodyHandlers.ofString())
        String hResponseBody = hResponse.body()

        project.logger.lifecycle("${greenText}🤖 👋 Hello Human!${resetText}")

        def hResponseJson = new JsonSlurper().parseText(hResponseBody)
        String bearerToken = hResponseJson.token
        if (!bearerToken) {
            project.logger.lifecycle("${redText}🤖 Failed to authenticate. No token received.${resetText}")
            return
        }

        def conversationId = null

        while (true) {
            if (conversationId == null) {
                project.logger.lifecycle("${greenText}🤖 What is your question?${resetText}")
                project.logger.lifecycle("")
            }

            //User Question
            project.logger.lifecycle("${yellowText}👤 You:")
            if (question == null || question == "") {
                question = reader.readLine()?.trim()
            } else {
                project.logger.lifecycle(question)
            }
            project.logger.lifecycle("${resetText}")

            if (question?.equalsIgnoreCase("exit")) {
                project.logger.lifecycle("${greenText}🤖 ¡Good bye! 👋${resetText}")
                break
            }

            def requestBodyMap = [
                    question: question,
                    app_id  : app_id
            ]
            if (conversationId != null) {
                requestBodyMap.conversation_id = conversationId
            }
            String requestBody = JsonOutput.toJson(requestBodyMap)


            String translationURL = "${etendoHost}/sws/copilot/question"
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(translationURL))
                    .header("Content-Type", "application/json")
                    .header("Authorization", "Bearer ${bearerToken}")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build()
            HttpResponse<String> response = hClient.send(request, HttpResponse.BodyHandlers.ofString())
            int httpCode = response.statusCode()
            String responseBody = response.body()

            if (httpCode >= 400) {
                project.logger.lifecycle("${redText}*** Task failed with status code ${httpCode}: ${responseBody} ***${resetText}")
                return
            } else {
                var responseJson = new JsonSlurper().parseText(responseBody)
                project.logger.lifecycle("${greenText}🤖 " + responseJson.response +
                        " (type 'exit' to end)${resetText}")
                project.logger.lifecycle("")
                if (conversationId == null && responseJson.conversation_id) {
                    conversationId = responseJson.conversation_id
                }
                if (project.hasProperty("single")) {
                    break
                }
                question = null
            }
        }
    }
}

task 'copilot.build' {
    doLast {
        project.logger.info("🤖 Executing Copilot Configuration Loader")
        File copilotDir = new File(project.buildDir.path, COPILOT)
        copilotDir.deleteDir()

        boolean copilotExists = false
        Project moduleProject = project.findProject(":${BASE_MODULE_DIR}")
        File jarModulesLocation = new File(project.buildDir, "etendo" + File.separator + MODULES_PROJECT)
        File copilotJarModule = new File(jarModulesLocation, COPILOT_MODULE)
        Project copilotProject = null
        if (moduleProject != null) {
            copilotProject = moduleProject.findProject(COPILOT_MODULE)
        }

        if (copilotProject != null || copilotJarModule.exists()) {
            copilotExists = true
            def sourcePath = copilotProject != null ? copilotProject.projectDir.path : copilotJarModule.path
            int counter = 0

            project.copy {
                from sourcePath
                into "${project.buildDir.path}${File.separator}copilot"
                includeEmptyDirs false
                exclude "**/.git/**"
                exclude "**/node_modules/**"
                exclude "**/.venv/**"
                eachFile { fileCopyDetails ->
                    counter++
                    project.logger.info("Copying Copilot files ${counter}: ${fileCopyDetails.file.path}")
                }

            }
        }

        if (copilotExists) {
            File toolsConfigFile = new File(project.buildDir, COPILOT + File.separator + TOOLS_CONFIG_FILE)
            String toolDependencyFileName = getToolsDependenciesFileName(project)
            File toolsDependenciesFileMain = new File(project.buildDir, COPILOT + File.separator + toolDependencyFileName)
            def toolsConfigJson = new JsonSlurper().parseText(toolsConfigFile.readLines().join(" "))

            // Get tools in SOURCES
            if (moduleProject != null) {
                moduleProject.subprojects.each { subproject ->
                    File toolsDir = new File(subproject.projectDir, "tools")
                    if (toolsDir.exists() && !subproject.name.equals(COPILOT_MODULE)) {
                        project.copy {
                            from {
                                toolsDir.path
                            }
                            into "${project.buildDir.path}${File.separator}copilot${File.separator}tools"
                        }
                        toolsDir.listFiles().each { file ->
                            toolsConfigJson.third_party_tools[file.name.replaceFirst(~/\.[^\.]+$/, '')] = true
                        }
                        def json_data = JsonOutput.toJson(toolsConfigJson)
                        toolsConfigFile.write(JsonOutput.prettyPrint(json_data))
                        //lets read the Dependencies file of the subproject and add it to the main one
                        File toolsDependenciesFile = new File(subproject.projectDir, toolDependencyFileName)
                        if (toolsDependenciesFile.exists()) {
                            //add a line break
                            toolsDependenciesFileMain.append('\n')
                            toolsDependenciesFileMain.append(toolsDependenciesFile.text)
                            project.logger.info("Added dependencies from ${subproject.name} to main dependencies file")
                        }
                    }
                }
            }

            // Get tools in JARS
            jarModulesLocation.listFiles().each { jarModule ->
                File jarModuleToolsDir = new File(jarModule, "tools")
                if (jarModuleToolsDir.exists() && !jarModule.name.equals(COPILOT_MODULE)) {
                    project.copy {
                        from {
                            jarModuleToolsDir.path
                        }
                        into "${project.buildDir.path}${File.separator}copilot${File.separator}tools"
                    }
                    jarModuleToolsDir.listFiles().each { file ->
                        toolsConfigJson.third_party_tools[file.name.replaceFirst(~/\.[^\.]+$/, '')] = true
                    }
                    def json_data = JsonOutput.toJson(toolsConfigJson)
                    toolsConfigFile.write(JsonOutput.prettyPrint(json_data))
                    //lets read the Dependencies file of the subproject and add it to the main one
                    File toolsDependenciesFile = new File(jarModule, toolDependencyFileName)
                    if (toolsDependenciesFile.exists()) {
                        toolsDependenciesFileMain.append('\n')
                        toolsDependenciesFileMain.append(toolsDependenciesFile.text)
                        project.logger.info("Added dependencies from ${jarModule.name} to main dependencies file")
                    }
                }
            }
        }
    }
}
task 'copilot.restart' {
    dependsOn 'copilot.build'
    doLast {
        project.logger.lifecycle("🤖 Restarting Copilot")
        if (project.hasProperty("docker_com.etendoerp.copilot") ? project.property("docker_com.etendoerp.copilot").toBoolean() : false) {
            project.logger.lifecycle("🤖 Restarting Copilot using Docker")
            executeDockerComposeCommand("restart copilot")
        }
    }
}

task 'copilot.start.deprecated' {
    doLast {
        String err = "The task 'copilot.start' is deprecated. Please use the 'resources.up' task to start the Copilot, because Copilot now is used as a Docker service of Etendo."
        err += " For more information, please check the documentation: https://docs.etendo.software/latest/developer-guide/etendo-copilot/installation/"
        throw new GradleException(err)
    }
}

def isTomcatDockerized() {
    return project.hasProperty("docker_com.etendoerp.tomcat") && project.property("docker_com.etendoerp.tomcat").toBoolean()
}

def isCopilotDockerized() {
    return project.hasProperty("docker_com.etendoerp.copilot") && project.property("docker_com.etendoerp.copilot").toBoolean()
}

def isOllamaInDocker() {
    return project.hasProperty("docker_com.etendoerp.copilot.ollama") && project.property("docker_com.etendoerp.copilot.ollama").toBoolean()
}

static def getDefaultEtendoHost(boolean tomcatEnabled, String strTomcatPort) {
    def tomcatToTomcat = tomcatEnabled ? "tomcat" : "localhost"
    return "http://${tomcatToTomcat}:${strTomcatPort}"
}

static def getDefaultEtendoHostDocker(boolean tomcatEnabled, boolean copilotEnabled, String strTomcatPort) {
    def copilotToTomcat = "localhost"
    if (copilotEnabled) {
        copilotToTomcat = tomcatEnabled ? "tomcat" : "host.docker.internal"
    }
    return "http://${copilotToTomcat}:${strTomcatPort}"
}

static def getDefaultCopilotHost(boolean tomcatEnabled, boolean copilotEnabled) {
    def tomcatToCopilot = "localhost"
    if (tomcatEnabled) {
        tomcatToCopilot = copilotEnabled ? "copilot" : "host.docker.internal"
    }
    return tomcatToCopilot
}

static def getDefaultOllamaHost(boolean copilotEnabled, boolean ollamaEnabled) {
    def copilotToOllama = "localhost"
    if (copilotEnabled) {
        copilotToOllama = ollamaEnabled ? "ollama" : "host.docker.internal"
    }
    return copilotToOllama
}

// Check if host.docker.internal is available
private boolean checkHostDockerInternalAvailability() {
    try {
        def checkCommand = ["sh", "-c", "docker run --rm --add-host=host.docker.internal:host-gateway alpine sh -c 'ping -c 1 -W 1 host.docker.internal > /dev/null 2>&1 && echo \"available\" || echo \"not_available\"'"]
        def process = checkCommand.execute()

        logger.info("Checking host.docker.internal availability: ${checkCommand.join(' ')}")

        def output = new StringBuilder()
        def error = new StringBuilder()

        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()

        def outputText = output.toString().trim()
        logger.info("host.docker.internal check output: '${outputText}'")

        if (exitCode == 0 && outputText.equals("available")) {
            logger.info("host.docker.internal is available and will be used")
            return true
        } else {
            logger.info("host.docker.internal is not available, falling back to bridge IP detection")
            return false
        }
    } catch (Exception e) {
        logger.warn("Failed to check host.docker.internal availability: ${e.message}")
        return false
    }
}

// Get gateway IP for Docker communication
private String getGatewayIpForDocker(String defaultIp, def reader, def yellow, def green, def reset) {
    // First, check if host.docker.internal is available
    if (checkHostDockerInternalAvailability()) {
        return "host.docker.internal"
    }

    // If not available, detect Docker bridge IP
    return detectDockerBridgeIP(defaultIp, reader, yellow, green, reset)
}

// Prompt user for bridge IP when auto-detection fails
private String promptUserForBridgeIP(String defaultIp, def reader, def yellow, def green, def reset) {
    println "${yellow}⚠️ WARNING: Failed to automatically detect Docker bridge IP.${reset}"
    println "${yellow}Please run the following command manually to get the Docker bridge IP:${reset}"
    println "${green}    docker run --rm alpine sh -c 'ip route show default | head -1 | cut -d\" \" -f3'${reset}"
    println ""
    System.out.print("${yellow}💬 Please enter the Docker bridge IP result from the command above, or press Enter to use default (${defaultIp}): \n${reset}")
    System.out.flush()

    def userInput = reader.readLine()?.trim()
    if (userInput && !userInput.isEmpty()) {
        logger.info("Using user-provided Docker bridge IP: ${userInput}")
        return userInput
    } else {
        logger.info("Using default Docker bridge IP: ${defaultIp}")
        return defaultIp
    }
}

// Auto-detect Docker bridge IP
private String detectDockerBridgeIP(String defaultIp, def reader, def yellow, def green, def reset) {
    try {
        def command = ["sh", "-c", "docker run --rm alpine sh -c 'ip route show default | head -1 | cut -d\" \" -f3'"]
        def process = command.execute()

        logger.info("Executing command to get Docker bridge IP: ${command.join(' ')}")

        def output = new StringBuilder()
        def error = new StringBuilder()

        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()

        logger.info("Process exit code: ${exitCode}")

        def outputText = output.toString()
        def errorText = error.toString()

        logger.info("Raw process output: '${outputText}'")
        logger.info("Process error output: '${errorText}'")

        if (exitCode == 0 && outputText && !outputText.trim().isEmpty()) {
            def bridgeIp = outputText.trim()
            logger.info("Successfully detected Docker bridge IP: '${bridgeIp}'")
            return bridgeIp
        } else {
            logger.warn("Command failed or returned empty output. Exit code: ${exitCode}, Error: ${errorText}")
            return promptUserForBridgeIP(defaultIp, reader, yellow, green, reset)
        }
    } catch (Exception e) {
        logger.error("Exception occurred while getting Docker bridge IP: ${e.message}", e)
        logger.error("Exception class: ${e.class.name}")
        if (e.cause) {
            logger.error("Caused by: ${e.cause.message}")
        }
        return promptUserForBridgeIP(defaultIp, reader, yellow, green, reset)
    }
}

task 'copilot.env.file' {
    description = 'Generates the .env file for copilot'
    group = 'Docker'

    doLast {
        def props = envFile()
        def env = props.envFile
        def tomcatPort = env.hasProperty("TOMCAT_PORT") ? env.property("TOMCAT_PORT").toString() : "8080"

        def contextName = env.hasProperty("CONTEXT_NAME") ? env.property("CONTEXT_NAME").toString() : "etendo"

        def strTomcatPort = tomcatPort + "/" + contextName

        def tomcatEnabled = isTomcatDockerized()
        def copilotEnabled = isCopilotDockerized()
        def ollamaEnabled = isOllamaInDocker()

        def etendoHost = project.hasProperty("ETENDO_HOST") ? project.property("ETENDO_HOST").toString() : getDefaultEtendoHost(tomcatEnabled, strTomcatPort)
        def etendoHostDocker = project.hasProperty("ETENDO_HOST_DOCKER") ? project.property("ETENDO_HOST_DOCKER").toString() : getDefaultEtendoHostDocker(tomcatEnabled, copilotEnabled, strTomcatPort)
        def copilotHost = project.hasProperty("COPILOT_HOST") ? project.property("COPILOT_HOST").toString() : getDefaultCopilotHost(tomcatEnabled, copilotEnabled)
        def copilotPort = project.hasProperty("COPILOT_PORT") ? project.property("COPILOT_PORT").toString() : "5005"
        def copilotPortDebug = project.hasProperty("COPILOT_PORT_DEBUG") ? project.property("COPILOT_PORT_DEBUG").toString() : "5100"
        def copilotImageTag = project.hasProperty("COPILOT_IMAGE_TAG") ? project.property("COPILOT_IMAGE_TAG").toString() : "master"
        def copilotPullImage = project.hasProperty("COPILOT_PULL_IMAGE") ? project.property("COPILOT_PULL_IMAGE").toString() : "true"
        def copilotOllamaHost = project.hasProperty("COPILOT_OLLAMA_HOST") ? project.property("COPILOT_OLLAMA_HOST").toString() : getDefaultOllamaHost(copilotEnabled, ollamaEnabled)
        def copilotOllamaPort = project.hasProperty("COPILOT_OLLAMA_PORT") ? project.property("COPILOT_OLLAMA_PORT").toString() : "11434"
        env.withWriterAppend { writer ->
            writer.write("ETENDO_HOST=${etendoHost}\n")
            println "Writing ETENDO_HOST=${etendoHost}"

            writer.write("ETENDO_HOST_DOCKER=${etendoHostDocker}\n")
            println "Writing ETENDO_HOST_DOCKER=${etendoHostDocker}"

            writer.write("COPILOT_PORT=${copilotPort}\n")
            println "Writing COPILOT_PORT=${copilotPort}"

            writer.write("COPILOT_HOST=${copilotHost}\n")
            println "Writing COPILOT_HOST=${copilotHost}"

            writer.write("COPILOT_PORT_DEBUG=${copilotPortDebug}\n")
            println "Writing COPILOT_PORT_DEBUG=${copilotPortDebug}"

            writer.write("COPILOT_IMAGE_TAG=${copilotImageTag}\n")
            println "Writing COPILOT_IMAGE_TAG=${copilotImageTag}"

            writer.write("COPILOT_PULL_IMAGE=${copilotPullImage}\n")
            println "Writing COPILOT_PULL_IMAGE=${copilotPullImage}"

            writer.write("COPILOT_OLLAMA_HOST=${copilotOllamaHost}\n")
            println "Writing COPILOT_OLLAMA_HOST=${copilotOllamaHost}"

            writer.write("COPILOT_OLLAMA_PORT=${copilotOllamaPort}\n")
            println "Writing COPILOT_OLLAMA_PORT=${copilotOllamaPort}"

        }
    }
}

task 'copilot.variables.setup' {
    group = "configuration"
    description = "Detects and prints the suggested Copilot and Tomcat configuration variables."

    doLast {
        def yellow = "\u001B[33;1m"
        def red = "\u001B[31;1m"
        def green = "\u001B[32;1m"
        def reset = "\u001B[0m"

        def reader = new BufferedReader(new InputStreamReader(System.in))

        // === CONTEXT NAME ===
        def contextName = project.findProperty("context.name")
        if (!contextName) {
            throw new GradleException("${red}❌ ERROR: Missing required property 'context.name'. Use -Pcontext.name=your_context${reset}")
        }

        // === DETECT TOMCAT MODE ===
        def tomcatMode = null
        if (project.hasProperty("docker_com.etendoerp.tomcat") && project.property("docker_com.etendoerp.tomcat").toString() == "true") {
            tomcatMode = "docker"
        }

        if (!tomcatMode) {
            System.out.print("${yellow} \n💬 Please enter Tomcat mode ('docker', 'local', or 'server'):\n ${reset}")
            System.out.flush()
            tomcatMode = reader.readLine()?.trim()?.toLowerCase()
            if (!["docker", "local", "server"].contains(tomcatMode)) {
                throw new GradleException("${red}❌ Invalid Tomcat mode. Must be 'docker', 'local', or 'server'.${reset}")
            }
        }

        // === DETECT COPILOT MODE ===
        def copilotMode = null
        if (project.hasProperty("docker_com.etendoerp.copilot") && project.property("docker_com.etendoerp.copilot").toString() == "true") {
            copilotMode = "docker"
        }

        if (!copilotMode) {
            System.out.print("${yellow}\n💬 Please enter Copilot mode ('docker' or 'local'): \n${reset}")
            System.out.flush()
            copilotMode = reader.readLine()?.trim()?.toLowerCase()
            if (!["docker", "local"].contains(copilotMode)) {
                throw new GradleException("${red}❌ Invalid Copilot mode. Must be 'docker' or 'local'.${reset}")
            }
        }

        // === TOMCAT PORT ===
        def tomcatPort = project.findProperty("tomcatPort")
        if (!tomcatPort) {
            try {
                tomcatPort = envFile().property("TOMCAT_PORT")?.toString()
            } catch (Exception ignored) {
            }
        }

        if (!tomcatPort && tomcatMode != "docker") {
            if (tomcatMode == "server") {
                println "${yellow}\n💡 Tip: You can check the server port with:${reset}"
                println "${green}    sudo cat /etc/apache2/ports.conf \n${reset}"
            }

            System.out.print("${yellow}\n💬 Please enter the Tomcat port manually: \n${reset}")
            System.out.flush()
            tomcatPort = reader.readLine()?.trim()
            if (!tomcatPort) {
                throw new GradleException("${red}❌ ERROR: 'tomcatPort' is required when Tomcat is not dockerized.${reset}")
            }
        }

        if (!tomcatPort && tomcatMode == "docker") {
            tomcatPort = "8080"
        }

        // === COPILOT PORT ===
        def copilotPort = project.findProperty("copilotPort") ?: "5005"

        // === VARIABLE CONSTRUCTION ===
        def etendoHost
        def etendoHostDocker
        def copilotHost
        if (tomcatMode == "docker" && copilotMode == "docker") {
            etendoHost = "http://tomcat:8080/${contextName}"
            etendoHostDocker = etendoHost
            copilotHost = "copilot"
        } else if (copilotMode == "docker" && tomcatMode != "docker") {
            def defaultIp = "172.17.0.1"
            def gatewayIp = getGatewayIpForDocker(defaultIp, reader, yellow, green, reset)

            etendoHost = "http://localhost:${tomcatPort}/${contextName}"
            etendoHostDocker = "http://${gatewayIp}:${tomcatPort}/${contextName}"
            copilotHost = "localhost"
        } else {
            etendoHost = "http://localhost:${tomcatPort}/${contextName}"
            etendoHostDocker = etendoHost
            copilotHost = "localhost"
        }

        // === OUTPUT ===
        println ""
        println "${green}✅ Suggested gradle.properties values:${reset}"
        println "-------------------------------------------"
        println "ETENDO_HOST=${etendoHost}"
        println "ETENDO_HOST_DOCKER=${etendoHostDocker}"
        println "COPILOT_HOST=${copilotHost}"
        println "COPILOT_PORT=${copilotPort}"
        println "-------------------------------------------"
        println ""
    }
}

afterEvaluate {
    if (isCopilotDockerized()) {
        tasks.named("smartbuild").configure { task ->
            task.finalizedBy("copilot.restart")
        }
        tasks.named("resources.up").configure { task ->
            task.dependsOn("copilot.build")
        }
        def strTask = isTomcatDockerized() ? "tomcat.env.file" : "generateEnvFile"
        tasks.named(strTask).configure { task ->
            task.finalizedBy("copilot.env.file")
        }
    }
    if (tasks.hasProperty("copilot.start")) {
        tasks.named("copilot.start").configure { task ->
            task.dependsOn("copilot.start.deprecated")
        }
    }
}
