import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.security.KeyPairGenerator
import java.security.spec.ECGenParameterSpec
import java.util.Base64
import java.util.UUID

final String TRUE = 'true'
final String SH = 'sh'
final String DASH_C = '-c'
final String COPILOT = 'copilot'
final String MODULES_PROJECT = "modules"
final String COPILOT_MODULE = "com.etendoerp.copilot"
final String ARG_PROPERTY = "arg"
final String COPILOT_PORT_PROPERTY = "COPILOT_PORT"
final String OPENAI_API_KEY_PROPERTY = "OPENAI_API_KEY"
final String COPILOT_DOCKER_REPO = "etendo_copilot_core"
final String COPILOT_IMAGE_TAG = 'COPILOT_IMAGE_TAG'
final String COPILOT_PULL_IMAGE = 'COPILOT_PULL_IMAGE'
final String COPILOT_DOCKER_CONTAINER_NAME = 'COPILOT_DOCKER_CONTAINER_NAME'
final String DEPENDENCIES_TOOLS_FILENAME = 'DEPENDENCIES_TOOLS_FILENAME'
final String BASE_MODULE_DIR = "modules"

final String EQUAL = '='

def jarsDir = new File(projectDir, "build${File.separator}etendo${File.separator}modules")
def sourceDir = new File(projectDir, "modules")

ext.sharedPrompt = ""
ext.errorMsg = null

private Iterable<File> processPropertiesFiles(File dir) {
    fileTree(dir: dir).matching {
        include '**/gradle.properties'
    }.each { file ->
        Properties properties = new Properties()
        file.withInputStream { stream ->
            properties.load(stream)
        }
        properties.each { key, value ->
            if (key.toString().startsWith('copilot.')) {
                tasks.create(name: key, group: 'copilot') {
                    finalizedBy 'copilot.do'
                    doLast {
                        sharedPrompt = value
                        for (def i = 0; i < 10; i++) {
                            String arg = "arg";
                            if (i > 0) {
                                arg = 'arg' + i
                            }
                            if (sharedPrompt.contains(arg)) {
                                if (!project.hasProperty(arg)) {
                                    errorMsg = "ü§ñ Please provide the parameter: " + arg + " (Ex. -P" + arg + "=value)"
                                    sharedPrompt = null
                                    return
                                }
                                sharedPrompt = value.replace('{' + arg + '}', project.findProperty(arg))
                            }
                        }
                    }
                }
            }
        }
    }
}

private String getToolsDependenciesFileName(Project project) {
    String toolsDependenciesFile = 'tools_deps.toml'
    try {
        Properties properties = envFile().properties
        String toolsDependenciesFileProp = properties.getOrDefault(DEPENDENCIES_TOOLS_FILENAME, toolsDependenciesFile).toString()
        String result = toolsDependenciesFileProp.isEmpty() ? toolsDependenciesFile : toolsDependenciesFileProp
        project.logger.info("Loaded TOOLS_DEPENDENCIES_FILE: ${result}")
    } catch (Exception e) {
        project.logger.info("Loaded TOOLS_DEPENDENCIES_FILE using default value: ${toolsDependenciesFile}")
        return toolsDependenciesFile
    }
}

processPropertiesFiles(jarsDir)
processPropertiesFiles(sourceDir)

task 'copilot.do' {
    doLast {
        def reader = new BufferedReader(new InputStreamReader(System.in))
        def yellowText = "\u001B[33;1m"
        def greenText = "\u001B[32;1m"
        def blueText = "\u001B[34;1m"
        def redText = "\u001B[31;1m"
        def resetText = "\u001B[0m"

        def etendoHost = project.findProperty('host')
        def username = project.findProperty('username')
        def password = project.findProperty('password')
        def app_id = project.findProperty("app_id")
        def role = project.findProperty("role")
        String question = project.findProperty("question")
        def contextName = env.hasProperty("CONTEXT_NAME") ? env.property("CONTEXT_NAME").toString() : "etendo"

        if (project.hasProperty("single")) {
            project.logger.lifecycle("${yellowText}ü§ñ Single mode enabled. Only one question will be asked.${resetText}")
        }

        if (username == null || username == "") {
            project.logger.lifecycle("${blueText}üëÆ Please provide the username:${resetText}")
            username = reader.readLine()?.trim()
        }
        if (password == null || password == "") {
            project.logger.lifecycle("${blueText}üëÆ Please provide the password:${resetText}")
            password = reader.readLine()?.trim()
            exec {
                commandLine 'clear'
            }
        }
        if (!etendoHost) {
            project.logger.lifecycle("${redText}ü§ñ Host not provided, using default (http://localhost:${tomcatPort}/${contextName}).${resetText}")
            etendoHost = "http://localhost:${tomcatPort}/${contextName}"
        }
        if (app_id == null || app_id == "") {
            project.logger.lifecycle("${redText}ü§ñ Please provide the parameter: app_id (Ex. -Papp_id=\'A1B2C3D4E5F6G7H8\').${resetText}")
            return
        }

        String login = JsonOutput.toJson([
                "username": username,
                "password": password
        ] + (role != null && !role.isEmpty() ? ["role": role] : [:]))

        String loginURL = "${etendoHost}/sws/login"

        HttpClient hClient = HttpClient.newHttpClient()
        HttpRequest hRequest = HttpRequest.newBuilder()
                .uri(URI.create(loginURL))
                .header("Content-Type", "application/json")
                .method("POST", HttpRequest.BodyPublishers.ofString(login))
                .build()

        HttpResponse<String> hResponse = hClient.send(hRequest, HttpResponse.BodyHandlers.ofString())
        String hResponseBody = hResponse.body()

        project.logger.lifecycle("${greenText}ü§ñ üëã Hello Human!${resetText}")

        def hResponseJson = new JsonSlurper().parseText(hResponseBody)
        String bearerToken = hResponseJson.token
        if (!bearerToken) {
            project.logger.lifecycle("${redText}ü§ñ Failed to authenticate. No token received.${resetText}")
            return
        }

        def conversationId = null

        while (true) {
            if (conversationId == null) {
                project.logger.lifecycle("${greenText}ü§ñ What is your question?${resetText}")
                project.logger.lifecycle("")
            }

            //User Question
            project.logger.lifecycle("${yellowText}üë§ You:")
            if (question == null || question == "") {
                question = reader.readLine()?.trim()
            } else {
                project.logger.lifecycle(question)
            }
            project.logger.lifecycle("${resetText}")

            if (question?.equalsIgnoreCase("exit")) {
                project.logger.lifecycle("${greenText}ü§ñ ¬°Good bye! üëã${resetText}")
                break
            }

            def requestBodyMap = [
                    question: question,
                    app_id  : app_id
            ]
            if (conversationId != null) {
                requestBodyMap.conversation_id = conversationId
            }
            String requestBody = JsonOutput.toJson(requestBodyMap)


            String translationURL = "${etendoHost}/sws/copilot/question"
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(translationURL))
                    .header("Content-Type", "application/json")
                    .header("Authorization", "Bearer ${bearerToken}")
                    .POST(HttpRequest.BodyPublishers.ofString(requestBody))
                    .build()
            HttpResponse<String> response = hClient.send(request, HttpResponse.BodyHandlers.ofString())
            int httpCode = response.statusCode()
            String responseBody = response.body()

            if (httpCode >= 400) {
                project.logger.lifecycle("${redText}*** Task failed with status code ${httpCode}: ${responseBody} ***${resetText}")
                return
            } else {
                var responseJson = new JsonSlurper().parseText(responseBody)
                project.logger.lifecycle("${greenText}ü§ñ " + responseJson.response +
                        " (type 'exit' to end)${resetText}")
                project.logger.lifecycle("")
                if (conversationId == null && responseJson.conversation_id) {
                    conversationId = responseJson.conversation_id
                }
                if (project.hasProperty("single")) {
                    break
                }
                question = null
            }
        }
    }
}

task 'copilot.build' {
    doLast {
        project.logger.info("ü§ñ Executing Copilot Configuration Loader")
        File copilotDir = new File(project.buildDir.path, COPILOT)
        copilotDir.deleteDir()

        boolean copilotExists = false
        Project moduleProject = project.findProject(":${BASE_MODULE_DIR}")
        File jarModulesLocation = new File(project.buildDir, "etendo" + File.separator + MODULES_PROJECT)
        File copilotJarModule = new File(jarModulesLocation, COPILOT_MODULE)
        Project copilotProject = null
        if (moduleProject != null) {
            copilotProject = moduleProject.findProject(COPILOT_MODULE)
        }

        if (copilotProject != null || copilotJarModule.exists()) {
            copilotExists = true
            def sourcePath = copilotProject != null ? copilotProject.projectDir.path : copilotJarModule.path
            int counter = 0

            project.copy {
                from sourcePath
                into "${project.buildDir.path}${File.separator}copilot"
                includeEmptyDirs false
                exclude "**/.git/**"
                exclude "**/node_modules/**"
                exclude "**/.venv/**"
                exclude "**/venv/**"
                eachFile { fileCopyDetails ->
                    counter++
                    project.logger.info("Copying Copilot files ${counter}: ${fileCopyDetails.file.path}")
                }

            }
        }

        if (copilotExists) {
            String toolDependencyFileName = getToolsDependenciesFileName(project)
            File toolsDependenciesFileMain = new File(project.buildDir, COPILOT + File.separator + toolDependencyFileName)

            // Get tools in SOURCES - simplified version without JSON generation
            if (moduleProject != null) {
                moduleProject.subprojects.each { subproject ->
                    File toolsDir = new File(subproject.projectDir, "tools")
                    if (toolsDir.exists() && !subproject.name.equals(COPILOT_MODULE)) {
                        // Copy tool files
                        project.copy {
                            from {
                                toolsDir.path
                            }
                            into "${project.buildDir.path}${File.separator}copilot${File.separator}tools"
                        }

                        // Merge dependencies file if it exists
                        File toolsDependenciesFile = new File(subproject.projectDir, toolDependencyFileName)
                        if (toolsDependenciesFile.exists()) {
                            //add a line break
                            toolsDependenciesFileMain.append('\n')
                            toolsDependenciesFileMain.append(toolsDependenciesFile.text)
                            project.logger.info("Added dependencies from ${subproject.name} to main dependencies file")
                        }
                    }
                }
            }

            // Get tools in JARS
            jarModulesLocation.listFiles().each { jarModule ->
                File jarModuleToolsDir = new File(jarModule, "tools")
                if (jarModuleToolsDir.exists() && !jarModule.name.equals(COPILOT_MODULE)) {
                    project.copy {
                        from {
                            jarModuleToolsDir.path
                        }
                        into "${project.buildDir.path}${File.separator}copilot${File.separator}tools"
                    }

                    //lets read the Dependencies file of the subproject and add it to the main one
                    File toolsDependenciesFile = new File(jarModule, toolDependencyFileName)
                    if (toolsDependenciesFile.exists()) {
                        toolsDependenciesFileMain.append('\n')
                        toolsDependenciesFileMain.append(toolsDependenciesFile.text)
                        project.logger.info("Added dependencies from ${jarModule.name} to main dependencies file")
                    }
                }
            }
        }
    }
}
task 'copilot.restart' {
    dependsOn 'copilot.build'
    doLast {
        project.logger.lifecycle("ü§ñ Restarting Copilot")
        if (project.hasProperty("docker_com.etendoerp.copilot") ? project.property("docker_com.etendoerp.copilot").toBoolean() : false) {
            project.logger.lifecycle("ü§ñ Restarting Copilot using Docker")
            executeDockerComposeCommand("restart copilot")
        }
    }
}

task 'copilot.start.deprecated' {
    doLast {
        String err = "The task 'copilot.start' is deprecated. Please use the 'resources.up' task to start the Copilot, because Copilot now is used as a Docker service of Etendo."
        err += " For more information, please check the documentation: https://docs.etendo.software/latest/developer-guide/etendo-copilot/installation/"
        throw new GradleException(err)
    }
}

def isTomcatDockerized() {
    return project.hasProperty("docker_com.etendoerp.tomcat") && project.property("docker_com.etendoerp.tomcat").toBoolean()
}

def isCopilotDockerized() {
    return project.hasProperty("docker_com.etendoerp.copilot") && project.property("docker_com.etendoerp.copilot").toBoolean()
}

def isOllamaInDocker() {
    return project.hasProperty("docker_com.etendoerp.copilot.ollama") && project.property("docker_com.etendoerp.copilot.ollama").toBoolean()
}

static def getDefaultEtendoHost(boolean tomcatEnabled, String strTomcatPort) {
    def tomcatToTomcat = tomcatEnabled ? "tomcat" : "localhost"
    return "http://${tomcatToTomcat}:${strTomcatPort}"
}

static def getDefaultEtendoHostDocker(boolean tomcatEnabled, boolean copilotEnabled, String strTomcatPort) {
    def copilotToTomcat = "localhost"
    if (copilotEnabled) {
        copilotToTomcat = tomcatEnabled ? "tomcat" : "host.docker.internal"
    }
    return "http://${copilotToTomcat}:${strTomcatPort}"
}

static def getDefaultCopilotHost(boolean tomcatEnabled, boolean copilotEnabled) {
    def tomcatToCopilot = "localhost"
    if (tomcatEnabled) {
        tomcatToCopilot = copilotEnabled ? "copilot" : "host.docker.internal"
    }
    return tomcatToCopilot
}

static def getDefaultOllamaHost(boolean copilotEnabled, boolean ollamaEnabled) {
    def copilotToOllama = "localhost"
    if (copilotEnabled) {
        copilotToOllama = ollamaEnabled ? "ollama" : "host.docker.internal"
    }
    return copilotToOllama
}

// Check if host.docker.internal is available
private boolean checkHostDockerInternalAvailability() {
    try {
        def checkCommand = ["sh", "-c", "docker run --rm --add-host=host.docker.internal:host-gateway alpine sh -c 'ping -c 1 -W 1 host.docker.internal > /dev/null 2>&1 && echo \"available\" || echo \"not_available\"'"]
        def process = checkCommand.execute()

        logger.info("Checking host.docker.internal availability: ${checkCommand.join(' ')}")

        def output = new StringBuilder()
        def error = new StringBuilder()

        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()

        def outputText = output.toString().trim()
        logger.info("host.docker.internal check output: '${outputText}'")

        if (exitCode == 0 && outputText.equals("available")) {
            logger.info("host.docker.internal is available and will be used")
            return true
        } else {
            logger.info("host.docker.internal is not available, falling back to bridge IP detection")
            return false
        }
    } catch (Exception e) {
        logger.warn("Failed to check host.docker.internal availability: ${e.message}")
        return false
    }
}

// Auto-detect Docker bridge IP
private String detectDockerBridgeIP(String defaultIp, def reader, def yellow, def green, def reset) {
    try {
        def command = ["sh", "-c", "docker run --rm alpine sh -c 'ip route show default | head -1 | cut -d\" \" -f3'"]
        def process = command.execute()

        logger.info("Executing command to get Docker bridge IP: ${command.join(' ')}")

        def output = new StringBuilder()
        def error = new StringBuilder()

        process.consumeProcessOutput(output, error)
        def exitCode = process.waitFor()

        logger.info("Process exit code: ${exitCode}")

        def outputText = output.toString()
        def errorText = error.toString()

        logger.info("Raw process output: '${outputText}'")
        logger.info("Process error output: '${errorText}'")

        if (exitCode == 0 && outputText && !outputText.trim().isEmpty()) {
            def bridgeIp = outputText.trim()
            logger.info("Successfully detected Docker bridge IP: '${bridgeIp}'")
            return bridgeIp
        } else {
            logger.warn("Command failed or returned empty output. Exit code: ${exitCode}, Error: ${errorText}")
            return promptUserForBridgeIP(defaultIp, reader, yellow, green, reset)
        }
    } catch (Exception e) {
        logger.error("Exception occurred while getting Docker bridge IP: ${e.message}", e)
        logger.error("Exception class: ${e.class.name}")
        if (e.cause) {
            logger.error("Caused by: ${e.cause.message}")
        }
        return promptUserForBridgeIP(defaultIp, reader, yellow, green, reset)
    }
}

// Prompt user for bridge IP when auto-detection fails
private String promptUserForBridgeIP(String defaultIp, def reader, def yellow, def green, def reset) {
    println "${yellow}‚ö†Ô∏è WARNING: Failed to automatically detect Docker bridge IP.${reset}"
    println "${yellow}Please run the following command manually to get the Docker bridge IP:${reset}"
    println "${green}    docker run --rm alpine sh -c 'ip route show default | head -1 | cut -d\" \" -f3'${reset}"
    println ""
    System.out.print("${yellow}üí¨ Please enter the Docker bridge IP result from the command above, or press Enter to use default (${defaultIp}): \n${reset}")
    System.out.flush()

    def userInput = reader.readLine()?.trim()
    if (userInput && !userInput.isEmpty()) {
        logger.info("Using user-provided Docker bridge IP: ${userInput}")
        return userInput
    } else {
        logger.info("Using default Docker bridge IP: ${defaultIp}")
        return defaultIp
    }
}

// Get gateway IP for Docker communication
private String getGatewayIpForDocker(String defaultIp, def reader, def yellow, def green, def reset) {
    // First, check if host.docker.internal is available
    if (checkHostDockerInternalAvailability()) {
        return "host.docker.internal"
    }

    // If not available, detect Docker bridge IP
    return detectDockerBridgeIP(defaultIp, reader, yellow, green, reset)
}


task 'copilot.env.file' {
    description = 'Generates the .env file for copilot'
    group = 'Docker'

    doLast {
        def props = envFile()
        def env = props.envFile

        def contextName = env.hasProperty("CONTEXT_NAME") ? env.property("CONTEXT_NAME").toString() : "etendo"

        def strTomcatPort = tomcatPort + "/" + contextName

        def tomcatEnabled = isTomcatDockerized()
        def copilotEnabled = isCopilotDockerized()
        def ollamaEnabled = isOllamaInDocker()

        def etendoHost = project.hasProperty("ETENDO_HOST") ? project.property("ETENDO_HOST").toString() : getDefaultEtendoHost(tomcatEnabled, strTomcatPort)
        def etendoHostDocker = project.hasProperty("ETENDO_HOST_DOCKER") ? project.property("ETENDO_HOST_DOCKER").toString() : getDefaultEtendoHostDocker(tomcatEnabled, copilotEnabled, strTomcatPort)
        def copilotHost = project.hasProperty("COPILOT_HOST") ? project.property("COPILOT_HOST").toString() : getDefaultCopilotHost(tomcatEnabled, copilotEnabled)
        def copilotPort = project.hasProperty("COPILOT_PORT") ? project.property("COPILOT_PORT").toString() : "5005"
        def copilotPortMCP = project.hasProperty("COPILOT_PORT_MCP") ? project.property("COPILOT_PORT_MCP").toString() : "5006"
        def copilotPortDebug = project.hasProperty("COPILOT_PORT_DEBUG") ? project.property("COPILOT_PORT_DEBUG").toString() : "5100"
        def copilotImageTag = project.hasProperty("COPILOT_IMAGE_TAG") ? project.property("COPILOT_IMAGE_TAG").toString() : "master"
        def copilotPullImage = project.hasProperty("COPILOT_PULL_IMAGE") ? project.property("COPILOT_PULL_IMAGE").toString() : "true"
        def copilotOllamaHost = project.hasProperty("COPILOT_OLLAMA_HOST") ? project.property("COPILOT_OLLAMA_HOST").toString() : getDefaultOllamaHost(copilotEnabled, ollamaEnabled)
        def copilotOllamaPort = project.hasProperty("COPILOT_OLLAMA_PORT") ? project.property("COPILOT_OLLAMA_PORT").toString() : "11434"
        env.withWriterAppend { writer ->
            writer.write("ETENDO_HOST=${etendoHost}\n")
            println "Writing ETENDO_HOST=${etendoHost}"

            writer.write("ETENDO_HOST_DOCKER=${etendoHostDocker}\n")
            println "Writing ETENDO_HOST_DOCKER=${etendoHostDocker}"

            writer.write("COPILOT_PORT=${copilotPort}\n")
            println "Writing COPILOT_PORT=${copilotPort}"

            writer.write("COPILOT_PORT_MCP=${copilotPortMCP}\n")
            println "Writing COPILOT_PORT_MCP=${copilotPortMCP}"

            writer.write("COPILOT_HOST=${copilotHost}\n")
            println "Writing COPILOT_HOST=${copilotHost}"

            writer.write("COPILOT_PORT_DEBUG=${copilotPortDebug}\n")
            println "Writing COPILOT_PORT_DEBUG=${copilotPortDebug}"

            writer.write("COPILOT_IMAGE_TAG=${copilotImageTag}\n")
            println "Writing COPILOT_IMAGE_TAG=${copilotImageTag}"

            writer.write("COPILOT_PULL_IMAGE=${copilotPullImage}\n")
            println "Writing COPILOT_PULL_IMAGE=${copilotPullImage}"

            writer.write("COPILOT_OLLAMA_HOST=${copilotOllamaHost}\n")
            println "Writing COPILOT_OLLAMA_HOST=${copilotOllamaHost}"

            writer.write("COPILOT_OLLAMA_PORT=${copilotOllamaPort}\n")
            println "Writing COPILOT_OLLAMA_PORT=${copilotOllamaPort}"

        }
    }
}


task 'copilot.variables.setup' {
    group = "configuration"
    description = "Detects and prints the suggested Copilot and Tomcat configuration variables."

    doLast {
        def yellow = "\u001B[33;1m"
        def red = "\u001B[31;1m"
        def green = "\u001B[32;1m"
        def reset = "\u001B[0m"

        def reader = new BufferedReader(new InputStreamReader(System.in))

        // === CONTEXT NAME ===
        def contextName = project.findProperty("context.name")
        if (!contextName) {
            throw new GradleException("${red}‚ùå ERROR: Missing required property 'context.name'. Use -Pcontext.name=your_context${reset}")
        }

        // === DETECT TOMCAT MODE ===
        def tomcatMode = null
        if (project.hasProperty("docker_com.etendoerp.tomcat") && project.property("docker_com.etendoerp.tomcat").toString() == "true") {
            tomcatMode = "docker"
        }

        while (!tomcatMode) {
            //check sources.path property, if starts with /opt/EtendoERP, suggest server mode
            def sourcesPath = project.findProperty("sources.path")
            if (sourcesPath && sourcesPath.toString().startsWithIgnoreCase("/opt/EtendoERP")) {
                System.out.println("${yellow}üí° Detected sources.path in /opt/EtendoERP, suggesting 'server' mode for Tomcat.${reset}")
            }
            System.out.println("${yellow} Select Tomcat mode:${reset}")
            System.out.println("${yellow}üí° Mode 'docker' is for when Tomcat runs in a Docker container (using Tomcat Docker module).${reset}")
            System.out.println("${yellow}üí° Mode 'local' is for when Tomcat runs directly on the host machine (typical local development setup).${reset}")
            System.out.println("${yellow}üí° Mode 'server' is for when Tomcat runs in a server environment.${reset}")
            System.out.println("")
            System.out.println("${yellow}üí¨ Please enter Tomcat mode ('docker', 'local', or 'server'. By default 'local' will be used.): ${reset}")

            System.out.flush()
            tomcatMode = reader.readLine()?.trim()?.toLowerCase()
            //for if empty input, set to local
            if (!tomcatMode || tomcatMode == "") {
                tomcatMode = "local"
            }
            if (!["local", "docker", "server"].contains(tomcatMode)) {
                println("${red}‚ùå Invalid Tomcat mode. Must be 'docker', 'local', or 'server'.${reset}")
                tomcatMode = null
            }
        }

        // === DETECT COPILOT MODE ===
        def copilotMode = null
        while (!copilotMode) {
            System.out.println("")
            System.out.println("${yellow} Select Copilot mode:${reset}")
            System.out.println("${yellow}üí° Mode 'docker' is for running Copilot in a Docker container (most cases). \n${reset}")
            System.out.println("${yellow}üí° Mode 'local' is for running Copilot directly on the host machine (for Copilot modules development).${reset}")
            System.out.println("")
            System.out.print("${yellow}\nüí¨ Please enter Copilot mode ('docker' or 'local'. By default 'docker' will be used.): \n${reset}")

            System.out.flush()
            copilotMode = reader.readLine()?.trim()?.toLowerCase()
            //for if empty input, set to docker
            if (!copilotMode || copilotMode == "") {
                copilotMode = "docker"
            }
            if (!["docker", "local"].contains(copilotMode)) {
                println("${red}‚ùå Invalid Copilot mode. Must be 'docker' or 'local'.${reset}")
                copilotMode = null
            }
        }

        // === TOMCAT PORT ===
        def tomcatPort = project.findProperty("tomcat.port")
        if (!tomcatPort) {
            try {
                tomcatPort = envFile().property("TOMCAT_PORT")?.toString()
            } catch (Exception ignored) {
            }
        }

        if (!tomcatPort && tomcatMode != "docker") {
            def defaultPort = tomcatMode == "server" ? "80" : "8080"
            if (tomcatMode == "server") {
                println "${yellow}\nüí° Tip: You can check the server port with:${reset}"
                println "${green}    sudo cat /etc/apache2/ports.conf \n${reset}"
            }

            System.out.print("${yellow}\nüí¨ Please enter the Tomcat port manually (default: ${defaultPort}): \n${reset}")
            System.out.flush()
            tomcatPort = reader.readLine()?.trim()
            if (!tomcatPort) {
                tomcatPort = defaultPort
            }
        }

        if (!tomcatPort && tomcatMode == "docker") {
            tomcatPort = "8080"
        }

        // === COPILOT PORT ===
        def copilotPort = project.findProperty("copilotPort") ?: "5005"

        // === COPILOT PORT FOR MCP SERVER ===
        def copilotPortMCP = project.hasProperty("copilotPortMCP") ? project.property("copilotPortMCP").toString() : "5006"
        // === VARIABLE CONSTRUCTION ===
        def etendoHost
        def etendoHostDocker
        def copilotHost

        if (tomcatMode == "docker" && copilotMode == "docker") {
            etendoHost = "http://tomcat:8080/${contextName}"
            etendoHostDocker = etendoHost
            copilotHost = "copilot"
        } else if (copilotMode == "docker" && tomcatMode != "docker") {
            def defaultIp = "172.17.0.1"
            def gatewayIp = getGatewayIpForDocker(defaultIp, reader, yellow, green, reset)

            etendoHost = "http://localhost:${tomcatPort}/${contextName}"
            etendoHostDocker = "http://${gatewayIp}:${tomcatPort}/${contextName}"
            copilotHost = "localhost"
        } else {
            etendoHost = "http://localhost:${tomcatPort}/${contextName}"
            etendoHostDocker = etendoHost
            copilotHost = "localhost"
        }

        // === OUTPUT ===
        // Prepare the properties map
        def properties = [
                'ETENDO_HOST'       : etendoHost,
                'ETENDO_HOST_DOCKER': etendoHostDocker,
                'COPILOT_HOST'      : copilotHost,
                'COPILOT_PORT'      : copilotPort,
                'COPILOT_PORT_MCP'  : copilotPortMCP
        ]

        // Add Docker configuration properties if user selected Docker modes
        if (copilotMode == "docker") {
            properties['docker_com.etendoerp.copilot'] = 'true'
        } else if (project.hasProperty("docker_com.etendoerp.copilot")) {
            properties['docker_com.etendoerp.copilot'] = 'false'
        }


        // Use the reusable function for JSON output (if available on the project)
        boolean wasWrittenAsJson = false
        if (project.hasProperty('writeResultsForInteractiveSetup')) {
            try {
                wasWrittenAsJson = project.writeResultsForInteractiveSetup(properties)
            } catch (Exception e) {
                // Fallback if the closure call fails - assume direct execution
                project.logger.debug("Failed to call project.writeResultsForInteractiveSetup: ${e.message}")
                wasWrittenAsJson = false
            }
        } else {
            project.logger.lifecycle("Interactive setup writer not registered on project; proceeding with console output.")
        }

        // If not written as JSON (direct execution), handle display here
        if (!wasWrittenAsJson) {
            // Human-readable output for direct execution
            println ""
            println "${green}‚úÖ Suggested gradle.properties values:${reset}"
            println "-------------------------------------------"

            properties.each { key, value ->
                println "${key}=${value}"
            }

            println "-------------------------------------------"
            println ""
        }
    }
}


afterEvaluate {
    if (isCopilotDockerized()) {
        tasks.named("smartbuild").configure { task ->
            task.finalizedBy("copilot.restart")
        }
        tasks.named("resources.up").configure { task ->
            task.dependsOn("copilot.build")
        }
        def strTask = isTomcatDockerized() ? "tomcat.env.file" : "generateEnvFile"
        tasks.named(strTask).configure { task ->
            task.finalizedBy("copilot.env.file")
        }
    }
    if (tasks.hasProperty("copilot.start")) {
        tasks.named("copilot.start").configure { task ->
            task.dependsOn("copilot.start.deprecated")
        }
    }
}

// Shared logic for Copilot Configuration
ext.performCopilotConfig = { Project project ->
    def contextName = project.findProperty("context.name") ?: "etendo"
    def tomcatPortVal = project.findProperty("tomcat.port") ?: "8080"
    def strTomcatPort = tomcatPortVal + "/" + contextName
    def tomcatEnabled = isTomcatDockerized()
    def etendoHost = getDefaultEtendoHost(tomcatEnabled, strTomcatPort)

    if (project.hasProperty('createDatabaseConnection')) {
        def dbConn = null
        try {
            dbConn = project.createDatabaseConnection(true)
        } catch (Exception e) {
            project.logger.debug("Failed to create DatabaseConnection: ${e.message}")
        }

        if (dbConn != null) {
            try (java.sql.Connection connection = dbConn.getConnection()) {
                def targetClientId = project.findProperty("clientId") ?: "23C59575B9CF467C9620760EB255B389"
                def roleParam = project.findProperty("role") ?: "0"

                def ensurePermissions = { java.sql.Connection conn, String clientId, String orgId, String roleId, List appIds ->
                    boolean exists = false
                    try (java.sql.PreparedStatement pstmt = conn.prepareStatement("SELECT count(*) FROM smfsws_config WHERE ad_client_id = ? AND ad_org_id = ?")) {
                        pstmt.setString(1, clientId)
                        pstmt.setString(2, orgId)
                        try (java.sql.ResultSet rs = pstmt.executeQuery()) {
                            if (rs.next()) {
                                if (rs.getInt(1) > 0) {
                                    exists = true
                                }
                            }
                        }
                    } catch (Exception e) {
                        project.logger.info("Table smfsws_config check failed for client ${clientId} and org ${orgId}: ${e.message}")
                        // If table doesn't exist, we can't insert either, so mark as exists to skip
                        exists = true
                    }

                    if (!exists) {
                        project.logger.lifecycle("Inserting default configuration into smfsws_config for Client ${clientId} and Org ${orgId}...")
                        try (java.sql.PreparedStatement pstmt = conn.prepareStatement(
                                "INSERT INTO smfsws_config (smfsws_config_id, ad_client_id, ad_org_id, isactive, created, createdby, updated, updatedby, expirationtime, privatekey) VALUES(?, ?, ?, 'Y', NOW(), '100', NOW(), '100', 0, ?)")) {

                            // Generate keys dynamically
                            KeyPairGenerator kpg = KeyPairGenerator.getInstance("EC")
                            kpg.initialize(new ECGenParameterSpec("secp256r1"))
                            java.security.KeyPair kp = kpg.generateKeyPair()

                            String privateKeyPem = "-----BEGIN PRIVATE KEY-----" + Base64.getEncoder().encodeToString(kp.getPrivate().getEncoded()) + "-----END PRIVATE KEY-----"
                            String publicKeyPem = "-----BEGIN PUBLIC KEY-----" + Base64.getEncoder().encodeToString(kp.getPublic().getEncoded()) + "-----END PUBLIC KEY-----"

                            def keyObject = [
                                    "private-key": privateKeyPem,
                                    "public-key" : publicKeyPem
                            ]
                            String jsonKeys = JsonOutput.toJson(keyObject)

                            pstmt.setString(1, UUID.randomUUID().toString().replace("-", "").toUpperCase())
                            pstmt.setString(2, clientId)
                            pstmt.setString(3, orgId)
                            pstmt.setString(4, jsonKeys)

                            pstmt.executeUpdate()
                            project.logger.lifecycle("‚úÖ Configuration inserted successfully for Client ${clientId} - Org ${orgId}.")
                            // Placeholder: aqu√≠ puede ir la l√≥gica para insertar permisos
                            // para el `roleId` sobre las aplicaciones listadas en `appIds`.
                            // Ejemplo: insertar filas en las tablas de permisos relacionando
                            // roleId <-> each appId in appIds.
                            // (Se dej√≥ vac√≠o por ahora; se implementar√° seg√∫n indicaciones posteriores.)
                        } catch (Exception e) {
                            project.logger.error("‚ùå Error inserting into smfsws_config for Client ${clientId} - Org ${orgId}: ${e.message}")
                        }
                    } else {
                        project.logger.lifecycle("‚ÑπÔ∏è Configuration in smfsws_config already exists for Client ${clientId} - Org ${orgId}.")
                    }
                }

                // Query etcop_app and partition app ids by System_app
                def systemAppIds = []
                def clientAppIds = []
                try (java.sql.Statement appStmt = connection.createStatement();
                        java.sql.ResultSet rsApps = appStmt.executeQuery("SELECT etcop_app_id, system_app FROM etcop_app")) {
                    while (rsApps.next()) {
                        def appId = rsApps.getString("etcop_app_id")
                        def sysFlag = rsApps.getString("system_app")
                        if (sysFlag != null && sysFlag.toUpperCase() == 'N') {
                            systemAppIds.add(appId)
                        } else {
                            clientAppIds.add(appId)
                        }
                    }
                    project.logger.lifecycle("‚ÑπÔ∏è Found ${systemAppIds.size()} system apps and ${clientAppIds.size()} client apps in etcop_app.")
                } catch (Exception e) {
                    project.logger.warn("‚ö†Ô∏è Failed to query etcop_app: ${e.message}")
                }

                // Create permissions for Client 0 Org 0 (role 0) using system apps
                ensurePermissions(connection, '0', '0', '0', systemAppIds)

                // Resolve admin role id for target client by querying ad_role (IS_Client_Admin = 'Y')
                def resolvedRoleId = roleParam.toString()
                if (targetClientId != '0') {
                    try (java.sql.PreparedStatement roleStmt = connection.prepareStatement("SELECT ad_role_id FROM ad_role WHERE ad_client_id = ? AND IS_Client_Admin = 'Y' LIMIT 1")) {
                        roleStmt.setString(1, targetClientId)
                        try (java.sql.ResultSet rsRole = roleStmt.executeQuery()) {
                            if (rsRole.next()) {
                                resolvedRoleId = rsRole.getString("ad_role_id")
                                project.logger.lifecycle("‚ÑπÔ∏è Resolved admin role for client ${targetClientId}: ${resolvedRoleId}")
                            } else {
                                project.logger.warn("‚ö†Ô∏è No admin role found in ad_role for client ${targetClientId}, falling back to provided role param: ${roleParam}")
                            }
                        }
                    } catch (Exception e) {
                        project.logger.warn("‚ö†Ô∏è Failed to query ad_role for client ${targetClientId}: ${e.message}. Using provided role param: ${roleParam}")
                    }
                }

                // Create permissions for Target Client and Specific Org (use resolved admin role)
                ensurePermissions(connection, targetClientId, "19404EAD144C49A0AF37D54377CF452D", resolvedRoleId, clientAppIds)

                // Placeholder: aqu√≠ ir√° la l√≥gica para a√±adir permisos concretos
                // usando las listas `systemAppIds` (para client '0') y `clientAppIds` (para el client objetivo).
                // Esa l√≥gica deber√° insertar las filas necesarias en las tablas de permisos
                // para los `roleId` correspondientes y las aplicaciones listadas.
                // (Implementar antes del login de verificaci√≥n cuando se decida la estructura exacta.)

                project.logger.lifecycle("üîÑ Attempting to login to verify configuration for both clients...")
                try {
                    String loginURL = "${etendoHost}/sws/login"
                    HttpClient hClient = HttpClient.newHttpClient()

                    // Helper to perform login and log token
                    def doLogin = { String username, String password, String roleId, String orgId ->
                        def payload = [
                            "username": username,
                            "password": password,
                            "role": roleId,
                            "organization": orgId,
                            "warehouse": "0"
                        ]
                        HttpRequest req = HttpRequest.newBuilder()
                                .uri(URI.create(loginURL))
                                .header("Content-Type", "application/json")
                                .POST(HttpRequest.BodyPublishers.ofString(JsonOutput.toJson(payload)))
                                .build()
                        HttpResponse<String> resp = hClient.send(req, HttpResponse.BodyHandlers.ofString())
                        if (resp.statusCode() == 200) {
                            def json = new JsonSlurper().parseText(resp.body())
                            if (json.token) {
                                project.logger.lifecycle("‚úÖ Login successful for role=${roleId}, org=${orgId}.")
                                return json.token
                            } else {
                                project.logger.error("‚ùå Login response did not contain a token for role=${roleId}, org=${orgId}.")
                            }
                        } else {
                            project.logger.error("‚ùå Login failed for role=${roleId}, org=${orgId}. Status: ${resp.statusCode()}. Body: ${resp.body()}")
                        }
                        return null
                    }

                    def processAgents = { HttpClient client, String username, String password, String roleId, String orgId, boolean isSystemAdmin ->
                        // 1. Login
                        def token = doLogin(username, password, roleId, orgId)
                        if (!token) return

                        project.logger.lifecycle("üîÑ Fetching agents for role ${roleId}...")
                        // 2. Fetch ALL Agents
                        HttpRequest agentsReq = HttpRequest.newBuilder()
                                .uri(URI.create("${etendoHost}/sws/com.etendoerp.etendorx.datasource/Agents?_startRow=0&_endRow=1000"))
                                .header("Content-Type", "application/json")
                                .header("Authorization", "Bearer ${token}")
                                .GET()
                                .build()

                        HttpResponse<String> agentsResp = client.send(agentsReq, HttpResponse.BodyHandlers.ofString())
                        if (agentsResp.statusCode() != 200) {
                            project.logger.error("‚ùå Failed to fetch agents. Status: ${agentsResp.statusCode()}")
                            return
                        }

                        def agentsJson = new JsonSlurper().parseText(agentsResp.body())
                        def agents = agentsJson.response.data

                        // 3. Filter Agents
                        def filteredAgents = agents.findAll { agent ->
                            def isSystemApp = agent.systemApp != null && (agent.systemApp.toString().equalsIgnoreCase('true') || agent.systemApp.toString().equalsIgnoreCase('Y'))
                            return isSystemAdmin ? isSystemApp : !isSystemApp
                        }

                        project.logger.lifecycle("‚ÑπÔ∏è Found ${filteredAgents.size()} agents to process for role ${roleId} (SystemAdmin: ${isSystemAdmin}).")

                        // 4. For each filtered agent
                        filteredAgents.each { agent ->
                            def agentId = agent.id

                            // Check if AgentAccess exists
                            def query = java.net.URLEncoder.encode("copilotApp.id=='${agentId}' and role.id=='${roleId}'", "UTF-8")
                            HttpRequest checkReq = HttpRequest.newBuilder()
                                    .uri(URI.create("${etendoHost}/sws/com.etendoerp.etendorx.datasource/AgentAccess?q=${query}&_startRow=0&_endRow=1"))
                                    .header("Content-Type", "application/json")
                                    .header("Authorization", "Bearer ${token}")
                                    .GET()
                                    .build()

                            HttpResponse<String> checkResp = client.send(checkReq, HttpResponse.BodyHandlers.ofString())
                            boolean accessExists = false
                            if (checkResp.statusCode() == 200) {
                                def checkJson = new JsonSlurper().parseText(checkResp.body())
                                if (checkJson.response.data && checkJson.response.data.size() > 0) {
                                    accessExists = true
                                }
                            }

                            if (!accessExists) {
                                project.logger.lifecycle("Granting access to agent ${agent.name} for role ${roleId}...")
                                // POST to grant access
                                def accessPayload = [
                                        "copilotApp": agentId,
                                        "role"      : roleId,
                                        "organization": orgId,
                                        "client"    : isSystemAdmin ? '0' : targetClientId,
                                        "active"    : true
                                ]
                                HttpRequest grantReq = HttpRequest.newBuilder()
                                        .uri(URI.create("${etendoHost}/sws/com.etendoerp.etendorx.datasource/AgentAccess"))
                                        .header("Content-Type", "application/json")
                                        .header("Authorization", "Bearer ${token}")
                                        .POST(HttpRequest.BodyPublishers.ofString(JsonOutput.toJson(accessPayload)))
                                        .build()

                                HttpResponse<String> grantResp = client.send(grantReq, HttpResponse.BodyHandlers.ofString())
                                if (grantResp.statusCode() == 200) {
                                    project.logger.lifecycle("‚úÖ Access granted for agent ${agent.name}.")
                                } else {
                                    project.logger.error("‚ùå Failed to grant access for agent ${agent.name}. Status: ${grantResp.statusCode()} Body: ${grantResp.body()}")
                                }
                            } else {
                                project.logger.lifecycle("‚ÑπÔ∏è Access already exists for agent ${agent.name}.")
                            }
                        }

                        // 5. Call /sws/copilot/assistants to trigger auto-config
                        HttpRequest triggerReq = HttpRequest.newBuilder()
                                .uri(URI.create("${etendoHost}/sws/copilot/assistants"))
                                .header("Content-Type", "application/json")
                                .header("Authorization", "Bearer ${token}")
                                .GET()
                                .build()
                        client.send(triggerReq, HttpResponse.BodyHandlers.ofString())
                        project.logger.lifecycle("‚úÖ Triggered assistant auto-config/caching.")
                    }

                    // Process Agents for System Admin (Client 0)
                    processAgents(hClient, 'admin', 'admin', '0', '0', true)

                    // Process Agents for Target Client
                    processAgents(hClient, 'admin', 'admin', resolvedRoleId.toString(), "19404EAD144C49A0AF37D54377CF452D", false)

                } catch (Exception e) {
                    project.logger.error("‚ùå Exception during login attempts: ${e.message}")
                }

            } catch (Exception e) {
                project.logger.error("Error with database connection: ${e.message}")
            }
        } else {
            project.logger.warn("‚ö†Ô∏è Database connection could not be established.")
        }
    }
}

// Initial Copilot configuration generator (non-interactive)
task 'copilot.initial.config' {
    group = 'configuration'
    description = 'Generates a suggested initial Copilot config file (non-interactive).'

    doLast {
        performCopilotConfig(project)
    }
}

// Register in AutoConfig
afterEvaluate {
    try {
        def copilotConfigurator = new com.etendoerp.autoconfig.AutoConfigurator() {
            String getName() { return "copilot" }
            String getDescription() { return "Generates a suggested initial Copilot configuration, including SWS master key setup, agent permissions to admin roles, and agent synchronizations. Requires Tomcat to be running." }
            void configure(Project p) {
                performCopilotConfig(p)
            }
        }
        com.etendoerp.autoconfig.AutoConfigTask.configurators.put("copilot", copilotConfigurator)
    } catch (Throwable t) {
        project.logger.debug("Could not register AutoConfigurator for Copilot: " + t.message)
    }
}
